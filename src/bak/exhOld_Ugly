void MemsGraph::build_UGLYOLD(const SplicingGraph& sg,
                      std::list<Mem>& MEMs_) {
    std::map<int, std::forward_list<Mem> > MEMs;
    for(const Mem& m : MEMs_) {
        int p = m.p;
        std::map<int, std::forward_list<Mem> >::iterator it = MEMs.find(p);
        if (it == MEMs.end()) {
            std::forward_list<Mem> ML;
            MEMs[p] = ML;
        }
        MEMs[p].push_front(m);
    }
    //for(std::list<Mem> Ms : MEMs) {
    //    Ms.sort(compareMEMs);
    //}
    for (std::map<int, std::forward_list<Mem> >::iterator it=MEMs.begin(); it!=MEMs.end(); ++it) {
        int p1 = it->first;
        for(Mem& m1 : it->second) {
            lemon::ListDigraph::Node node1;
            int id1 = sg.rank(m1.t-1);
            std::string exon1_text = sg.getExon(id1);
            // #################################################
            // START
            // #################################################
            if(p1<K0) {
                int err = 0;
                if(p1 == 1) {
                    err = 0;
                } else {
                    int l = p1-1;
                    std::string sub_P = read.substr(0,l);
                    std::string sub_E;
                    int exon_pref_len = m1.t - sg.select(id1)-1 - 1;
                    if(exon_pref_len < l) {
                        int shared_pref_len = l-exon_pref_len;
                        std::string exon_pref = exon1_text.substr(0, exon_pref_len);
                        err = l;
                        std::list<int> parents = sg.getParents(id1);
                        for(const int& par : parents) {
                            //Si guarda solo il padre, se Ã¨ lungo abbastanza (IF), si prende il suffisso,
                            //altrimenti tutto il testo e basta (senza andare indietro ancora)
                            std::string par_text = sg.getExon(par);
                            if(sg.select(par+1)-shared_pref_len-sg.select(par)-1>=0) {
                                sub_E = par_text.substr(sg.select(par+1)-shared_pref_len-sg.select(par)-1, shared_pref_len) + exon_pref;
                            } else {
                                sub_E = par_text + exon_pref;
                            }
                            int curr_err = e_distance(sub_P, sub_E);
                            if(curr_err < err) {
                                err = curr_err;
                            }
                        }
                    } else {
                        sub_E = exon1_text.substr(m1.t-l-sg.select(id1)-1-1, l);
                        err = e_distance(sub_P, sub_E);
                    }
                }
                if(err <= K2) {
                    //Si potrebbero creare chiusure transitive
                    if(m1.isNew) {
                        node1 = graph.addNode();
                        m1.setNode(node1);
                        nodes_map[node1] = m1;
                    } else {
                        node1 = m1.node;
                    }
                    lemon::ListDigraph::Arc arc = graph.addArc(start,node1);
                    edges_map[arc] = err;
                } else {
                    continue;
                }
            } else {
                if(m1.isNew) {
                    continue;
                } else {
                    node1 = m1.node;
                }
            }
            // #################################################
            // EXTENDING
            // #################################################
            int p2 = p1+m1.l-1;
            int max_p = p1+m1.l+K1;
            while(p2<max_p && p2<m) {
                for(Mem& m2 : MEMs[p2]) {
                    lemon::ListDigraph::Node node2;
                    int id2 = sg.rank(m2.t-1);
                    if(verbose) {
                        std::cout << "Checking " << m1.toStr() << " -> " << m2.toStr();
                    }
                    bool flag = false;
                    int err = 0;
                    if(id1 == id2) {
                        //m1 and m2 in the same exon
                        if(m1.t<m2.t && m2.t<m1.t+m1.l+K1 && m1.t+m1.l<m2.t+m2.l) {
                            if(verbose) {
                                std::cout << ": 1" << std::endl;
                            }
                            int gap_P = p2-p1-m1.l;
                            int gap_E = m2.t-m1.t-m1.l;
                            if(gap_P>=0 && gap_E>=0) {
                                if(abs(gap_P-gap_E)<=K2) {
                                    std::string sub_P = read.substr(m1.p+m1.l-1, m2.p-m1.p-m1.l);
                                    std::string sub_E = exon1_text.substr(m1.t+m1.l-sg.select(id1)-1-1, m2.t-m1.t-m1.l);
                                    err = e_distance(sub_P, sub_E);
                                }
                            } else if(gap_P<=0 && gap_E<=0) {
                                err = abs(gap_P-gap_E);
                            } else {
                                err = abs(gap_P) + abs(gap_E);
                            }
                            if(err < K2) {
                                flag = true;
                            }
                        }
                    } else {
                        //m1 and m2 in the same exon
                        if(sg.contain(id1, id2)) {
                            if(verbose) {
                                std::cout << ": 2" << std::endl;
                            }
                            std::string exon2_text = sg.getExon(id2);
                            std::string sub_E1 = exon1_text.substr(m1.t+m1.l-sg.select(id1)-1-1, sg.select(id1)+1-m1.t-m1.l);
                            std::string sub_E2 = exon2_text.substr(0,m2.t-sg.select(id2)-1-1);
                            std::string sub_E = sub_E1 + sub_E2;
                            int len_P = p2-p1-m1.l;
                            std::string sub_P;
                            if(len_P == 0) {
                                err = 0;
                            } else if(len_P<0) {
                                err = abs(len_P);
                            } else {
                                sub_P = read.substr(m1.p+m1.l-1,len_P);
                                err = e_distance(sub_P, sub_E);
                            }
                            if(err < K2) {
                                flag = true;
                            }
                        }
                    }
                    if(flag) {
                        if(m2.isNew) {
                            node2 = graph.addNode();
                            m2.setNode(node2);
                            nodes_map[node2] = m2;
                        } else {
                            node2 = m2.node;
                        }
                        lemon::ListDigraph::Arc arc = graph.addArc(node1,node2);
                        edges_map[arc] = err;
                    }
                }
                ++p2;
            }
            // #################################################
            // ENDING
            // #################################################
            if(p1+m1.l>m-K0) {
                int err = 0;
                int l = m-(p1+m1.l)+1;
                if(l == 0) {
                    err = 0;
                } else {
                    std::string sub_P = read.substr(p1+m1.l-1, l);
                    std::string sub_E;
                    int exon_suff_len = sg.select(id1+1) - (m1.t+m1.l) + 1;
                    if(exon_suff_len < l) {
                        std::list<int> sons = sg.getSons(id1);
                        int shared_suff_len = l-exon_suff_len;
                        std::string exon_suff;
                        if(exon_suff_len == 0) {
                            exon_suff = "";
                        } else {
                            exon_suff = exon1_text.substr(m1.t+m1.l-sg.select(id1)-1-1, exon_suff_len);
                        }
                        err = l;
                        for(const int& son : sons) {
                            std::string son_text = sg.getExon(son+1);
                            sub_E = exon_suff + son_text.substr(0, shared_suff_len);
                            int curr_err = e_distance(sub_P, sub_E);
                            if(curr_err < err) {
                                err = curr_err;
                            }
                        }
                    } else {
                        sub_E = exon1_text.substr(m1.t+m1.l-sg.select(id1)-1-1, l);
                        err = e_distance(sub_P, sub_E);
                    }
                }
                if(err <= K2) {
                    lemon::ListDigraph::Arc arc = graph.addArc(node1,end);
                    edges_map[arc] = err;
                }
            }
        }
        ++p1;
    }
    // #################################################
    // TRANSITIVE CLOSURE ON END NODE
    // #################################################
    std::list<lemon::ListDigraph::InArcIt> arcs_D;
    for(lemon::ListDigraph::InArcIt XZ (graph, end); XZ!=lemon::INVALID; ++XZ) {
        lemon::ListDigraph::Node X = graph.source(XZ);
        for(lemon::ListDigraph::OutArcIt XY (graph, X); XY!=lemon::INVALID; ++XY) {
            lemon::ListDigraph::Node Y = graph.target(XY);
            if(graph.id(Y)!=graph.id(end)) {
                for(lemon::ListDigraph::OutArcIt YZ (graph, Y); YZ!=lemon::INVALID; ++YZ) {
                    lemon::ListDigraph::Node Z = graph.target(YZ);
                    if(graph.id(Z)==graph.id(end)) {
                        if(edges_map[XY]+edges_map[YZ]<=edges_map[XZ]) {
                            arcs_D.push_back(XZ);
                        }
                    }
                }
            }
        }
    }
    for(const lemon::ListDigraph::InArcIt& a : arcs_D) {
        if(graph.valid(a)) {
            graph.erase(a);
        }
    }
    
    if(verbose) {
        save("./Graphs/Graph.dot");
    }
}
